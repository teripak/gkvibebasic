{% extends 'home/base.html' %}

{% block title %}홈 - 내가 만드는 나만의 AI 에이전트{% endblock %}

{% block content %}
<div class="main-layout">
    <!-- 왼쪽 영역 (1번창) - 문서 -->
    <aside class="left-panel" id="leftPanel">
        <div class="panel-header">
            <h3>📄 문서</h3>
            <button class="toggle-btn" onclick="togglePanel('left')" id="leftToggleBtn" title="숨기기">
                <span class="icon">‹</span>
            </button>
        </div>
        <div class="panel-content">
            <!-- 파일 선택 영역 -->
            <div class="file-select-area">
                <div class="file-input-container">
                    <input type="file" id="fileInput" multiple accept=".pdf,.doc,.docx,.txt,.png,.jpg,.jpeg" style="display: none;">
                    <label for="fileInput" class="file-input-label">
                        <span class="file-input-text">파일 선택</span>
                    </label>
                    <button class="upload-btn" onclick="uploadFiles()">
                        <span class="upload-icon">↑</span>
                    </button>
                    <label class="background-checkbox">
                        <input type="checkbox" id="backgroundUpload">
                        <span class="checkbox-text">백그라운드</span>
                    </label>
                </div>
            </div>

            <!-- 파일 목록 영역 -->
            <div class="file-list-area">
                <!-- 목록 헤더 -->
                <div class="list-header">
                    <div class="list-header-left">
                        <span class="list-title">파일명</span>
                    </div>
                    <div class="list-header-right">
                        <button class="header-btn settings-btn" title="설정">
                            <span class="icon">⚙</span>
                        </button>
                        <button class="header-btn delete-btn" title="삭제" onclick="deleteSelectedDocuments()">
                            <span class="icon">🗑</span>
                        </button>
                        <button class="header-btn reload-btn" title="새로고침" onclick="reloadFileList()">
                            <span class="icon">↻</span>
                        </button>
                        <input type="checkbox" class="select-all-checkbox" title="전체 선택" onchange="toggleSelectAll(this)">
                    </div>
                </div>

                <!-- 목록 본문 -->
                <div class="list-body" id="fileListBody">
                    {% for document in user_documents %}
                    <div class="file-item" data-document-id="{{ document.id }}">
                        <div class="status-indicator active"></div>
                        <div class="file-name">{{ document.file.name|slice:"Document/"|slice:":-1"|slice:"/"|last }}</div>
                        <input type="checkbox" class="file-checkbox" onchange="updateSelectAllCheckbox()">
                    </div>
                    {% empty %}
                    <div class="no-files">
                        <p>업로드된 문서가 없습니다.</p>
                    </div>
                    {% endfor %}
                </div>

                <!-- 페이지네이션 -->
                <div class="pagination-area">
                    <div class="pagination">
                        <button class="page-btn active">1</button>
                        <button class="page-btn">2</button>
                        <button class="page-btn">3</button>
                        <button class="page-btn">4</button>
                        <button class="page-btn">5</button>
                        <button class="page-btn nav-btn">»</button>
                        <button class="page-btn nav-btn">»»</button>
                    </div>
                </div>
            </div>
        </div>
    </aside>

    <!-- 중간 영역 (2번창) - 채팅 -->
    <main class="center-panel" id="centerPanel">
        <div class="panel-header">
            <h3>💬 채팅</h3>
        </div>
        <div class="panel-content">
            <div class="chat-container">
                <div class="chat-messages">
                    <div class="message ai-message">
                        <div class="message-avatar">🤖</div>
                        <div class="message-content">
                            안녕하세요! AI 에이전트입니다. 무엇을 도와드릴까요?
                        </div>
                    </div>
                    <div class="message user-message">
                        <div class="message-content">
                            안녕하세요! 문서 분석을 도와주세요.
                        </div>
                        <div class="message-avatar">👤</div>
                    </div>
                </div>
                <div class="chat-input-container">
                    <input type="text" class="chat-input" id="chatInput" placeholder="메시지를 입력하세요..." onkeypress="handleKeyPress(event)">
                    <button class="send-btn" onclick="sendMessage()">전송</button>
                </div>
            </div>
        </div>
    </main>

    <!-- 오른쪽 영역 (3번창) - 근거 -->
    <aside class="right-panel" id="rightPanel">
        <div class="panel-header">
            <h3>🔍 근거</h3>
            <button class="toggle-btn" onclick="togglePanel('right')" id="rightToggleBtn" title="숨기기">
                <span class="icon">›</span>
            </button>
        </div>
        <div class="panel-content">
            <div class="evidence-list">
                <h4>참조 근거</h4>
                <div class="evidence-item">
                    <div class="evidence-source">문서 1 - 페이지 3</div>
                    <div class="evidence-text">관련 내용이 여기에 표시됩니다...</div>
                </div>
                <div class="evidence-item">
                    <div class="evidence-source">문서 2 - 페이지 1</div>
                    <div class="evidence-text">추가 참조 정보가 표시됩니다...</div>
                </div>
                <div class="evidence-item">
                    <div class="evidence-source">문서 3 - 페이지 5</div>
                    <div class="evidence-text">더 많은 근거 자료가 있습니다...</div>
                </div>
            </div>
        </div>
    </aside>
</div>
{% endblock %}

{% block extra_js %}

function hidePanel(side) {
    const panel = document.getElementById(side + 'Panel');
    const toggleBtn = document.getElementById(side + 'ToggleBtn');
    
    if (panel && toggleBtn) {
        // 패널을 숨김 상태로 설정
        panel.classList.add('panel-hidden');
        
        // 토글 버튼 아이콘과 툴팁 변경
        const icon = toggleBtn.querySelector('.icon');
        if (side === 'left') {
            icon.textContent = '›';
            toggleBtn.title = '보이기';
        } else {
            icon.textContent = '‹';
            toggleBtn.title = '보이기';
        }
        
        // 로컬 스토리지에 상태 저장
        localStorage.setItem(side + 'PanelHidden', 'true');
        
        // 중간 패널 크기 조정
        adjustCenterPanel();
    }
}

function showPanel(side) {
    const panel = document.getElementById(side + 'Panel');
    const toggleBtn = document.getElementById(side + 'ToggleBtn');
    
    if (panel && toggleBtn) {
        // 패널을 보이게 함
        panel.classList.remove('panel-hidden');
        
        // 토글 버튼 아이콘과 툴팁 변경
        const icon = toggleBtn.querySelector('.icon');
        if (side === 'left') {
            icon.textContent = '‹';
            toggleBtn.title = '숨기기';
        } else {
            icon.textContent = '›';
            toggleBtn.title = '숨기기';
        }
        
        // 로컬 스토리지에서 상태 제거
        localStorage.removeItem(side + 'PanelHidden');
        
        // 중간 패널 크기 조정
        adjustCenterPanel();
    }
}

function adjustCenterPanel() {
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');
    const centerPanel = document.getElementById('centerPanel');
    
    if (!leftPanel || !rightPanel || !centerPanel) return;
    
    const leftHidden = leftPanel.classList.contains('panel-hidden');
    const rightHidden = rightPanel.classList.contains('panel-hidden');
    
    if (leftHidden && rightHidden) {
        centerPanel.style.width = '100%';
    } else if (leftHidden || rightHidden) {
        centerPanel.style.width = '75%';
    } else {
        centerPanel.style.width = '50%';
    }
}

// 채팅 관련 함수들
let isLoading = false;

function handleKeyPress(event) {
    if (event.key === 'Enter' && !isLoading) {
        sendMessage();
    }
}

function sendMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message || isLoading) {
        return;
    }
    
    // 선택된 문서들 가져오기
    const selectedDocuments = getSelectedDocuments();
    
    // 입력 필드 비우기
    chatInput.value = '';
    
    // 사용자 메시지 추가
    addMessageToChat(message, 'user');
    
    // 로딩 상태 설정
    isLoading = true;
    updateSendButton(true);
    
    // 로딩 애니메이션 추가
    addLoadingMessage();
    
    // API 호출 (RAG 지원)
    const requestBody = {
        message: message
    };
    
    // 선택된 문서가 있으면 RAG 모드로 전송
    if (selectedDocuments.length > 0) {
        requestBody.selected_documents = selectedDocuments;
    }
    
    fetch('/api/send-chat-message/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(requestBody)
    })
    .then(response => response.json())
    .then(data => {
        // 로딩 메시지 제거
        removeLoadingMessage();
        
        if (data.success) {
            // AI 응답 추가
            addMessageToChat(data.message, 'ai');
            
            // RAG 모드인 경우 참조 청크들 표시
            if (data.referenced_chunks && data.referenced_chunks.length > 0) {
                displayReferencedChunks(data.referenced_chunks);
            }
        } else {
            // 오류 메시지 표시
            addMessageToChat('오류: ' + data.message, 'ai', true);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        // 로딩 메시지 제거
        removeLoadingMessage();
        addMessageToChat('서버 오류가 발생했습니다.', 'ai', true);
    })
    .finally(() => {
        isLoading = false;
        updateSendButton(false);
        chatInput.focus();
    });
}

function addMessageToChat(content, sender, isError = false) {
    const chatMessages = document.querySelector('.chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    
    if (isError) {
        messageDiv.style.color = '#ff6b6b';
    }
    
    if (sender === 'user') {
        messageDiv.innerHTML = `
            <div class="message-content">${escapeHtml(content)}</div>
            <div class="message-avatar">👤</div>
        `;
    } else {
        messageDiv.innerHTML = `
            <div class="message-avatar">🤖</div>
            <div class="message-content">${escapeHtml(content)}</div>
        `;
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function addLoadingMessage() {
    const chatMessages = document.querySelector('.chat-messages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message ai-message';
    loadingDiv.id = 'loading-message';
    
    loadingDiv.innerHTML = `
        <div class="message-avatar">🤖</div>
        <div class="loading-message">
            <span>AI가 답변을 준비하고 있습니다</span>
            <div class="typing-indicator">
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
                <div class="typing-dot"></div>
            </div>
        </div>
    `;
    
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function removeLoadingMessage() {
    const loadingMessage = document.getElementById('loading-message');
    if (loadingMessage) {
        loadingMessage.remove();
    }
}

function updateSendButton(loading) {
    const sendBtn = document.querySelector('.send-btn');
    if (loading) {
        sendBtn.textContent = '전송중...';
        sendBtn.disabled = true;
    } else {
        sendBtn.textContent = '전송';
        sendBtn.disabled = false;
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// 페이지 로드 시 채팅 이력 불러오기
document.addEventListener('DOMContentLoaded', function() {
    loadChatHistory();
    loadCurrentLLM();
    loadDocumentList();
});

function uploadFiles() {
    const fileInput = document.getElementById('fileInput');
    const files = fileInput.files;
    
    if (files.length === 0) {
        alert('파일을 선택해주세요.');
        return;
    }
    
    // 파일 크기 체크 (10MB)
    const maxSize = 10 * 1024 * 1024; // 10MB
    for (let file of files) {
        if (file.size > maxSize) {
            alert(`파일 "${file.name}"의 크기가 10MB를 초과합니다.`);
            return;
        }
    }
    
    // FormData 생성
    const formData = new FormData();
    for (let file of files) {
        formData.append('file', file);
    }
    
    // 업로드 진행 표시
    showUploadProgress();
    
    // 파일 업로드
    fetch('/api/upload-document/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        hideUploadProgress();
        
        if (data.success) {
            alert(data.message);
            // 파일 목록 새로고침
            loadDocumentList();
            // 파일 입력 초기화
            fileInput.value = '';
        } else {
            alert('오류: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        hideUploadProgress();
        alert('파일 업로드 중 오류가 발생했습니다.');
    });
}

function showUploadProgress() {
    const uploadBtn = document.querySelector('.upload-btn');
    uploadBtn.innerHTML = '<span class="upload-icon">⏳</span>';
    uploadBtn.disabled = true;
}

function hideUploadProgress() {
    const uploadBtn = document.querySelector('.upload-btn');
    uploadBtn.innerHTML = '<span class="upload-icon">↑</span>';
    uploadBtn.disabled = false;
}

function loadDocumentList() {
    fetch('/api/get-user-documents/')
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            updateDocumentList(data.documents);
        }
    })
    .catch(error => {
        console.error('Error loading documents:', error);
    });
}

function updateDocumentList(documents) {
    const fileListBody = document.getElementById('fileListBody');
    
    if (documents.length === 0) {
        fileListBody.innerHTML = '<div class="no-files"><p>업로드된 문서가 없습니다.</p></div>';
        // 전체 선택 체크박스 초기화
        const selectAllCheckbox = document.querySelector('.select-all-checkbox');
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
        return;
    }
    
    fileListBody.innerHTML = '';
    documents.forEach(doc => {
        const fileItem = document.createElement('div');
        fileItem.className = 'file-item';
        fileItem.setAttribute('data-document-id', doc.id);
        
        fileItem.innerHTML = `
            <div class="status-indicator active"></div>
            <div class="file-name">${doc.filename}</div>
            <input type="checkbox" class="file-checkbox" onchange="updateSelectAllCheckbox()">
        `;
        
        fileListBody.appendChild(fileItem);
    });
    
    // 전체 선택 체크박스 초기화
    const selectAllCheckbox = document.querySelector('.select-all-checkbox');
    selectAllCheckbox.checked = false;
    selectAllCheckbox.indeterminate = false;
}

function logout() {
    if (confirm('정말 로그아웃하시겠습니까?')) {
        window.location.href = '/logout/';
    }
}

function reloadFileList() {
    loadDocumentList();
}

function toggleSelectAll(selectAllCheckbox) {
    const fileCheckboxes = document.querySelectorAll('.file-checkbox');
    fileCheckboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
    });
}

function updateSelectAllCheckbox() {
    const fileCheckboxes = document.querySelectorAll('.file-checkbox');
    const selectAllCheckbox = document.querySelector('.select-all-checkbox');
    
    const checkedCount = document.querySelectorAll('.file-checkbox:checked').length;
    const totalCount = fileCheckboxes.length;
    
    if (checkedCount === 0) {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = false;
    } else if (checkedCount === totalCount) {
        selectAllCheckbox.checked = true;
        selectAllCheckbox.indeterminate = false;
    } else {
        selectAllCheckbox.checked = false;
        selectAllCheckbox.indeterminate = true;
    }
}

function deleteSelectedDocuments() {
    const selectedCheckboxes = document.querySelectorAll('.file-checkbox:checked');
    
    if (selectedCheckboxes.length === 0) {
        alert('삭제할 문서를 선택해주세요.');
        return;
    }
    
    const documentIds = Array.from(selectedCheckboxes).map(checkbox => {
        const fileItem = checkbox.closest('.file-item');
        return fileItem.getAttribute('data-document-id');
    });
    
    if (confirm(`선택한 ${documentIds.length}개의 문서를 삭제하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.`)) {
        // 삭제 진행 표시
        showDeleteProgress();
        
        // 삭제 API 호출
        fetch('/api/delete-documents/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({
                document_ids: documentIds
            })
        })
        .then(response => response.json())
        .then(data => {
            hideDeleteProgress();
            
            if (data.success) {
                alert(data.message);
                // 문서 목록 새로고침
                loadDocumentList();
                // 전체 선택 체크박스 초기화
                const selectAllCheckbox = document.querySelector('.select-all-checkbox');
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else {
                alert('오류: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            hideDeleteProgress();
            alert('문서 삭제 중 오류가 발생했습니다.');
        });
    }
}

function showDeleteProgress() {
    const deleteBtn = document.querySelector('.delete-btn');
    deleteBtn.innerHTML = '<span class="icon">⏳</span>';
    deleteBtn.disabled = true;
}

function hideDeleteProgress() {
    const deleteBtn = document.querySelector('.delete-btn');
    deleteBtn.innerHTML = '<span class="icon">🗑</span>';
    deleteBtn.disabled = false;
}

function loadChatHistory() {
    fetch('/api/get-chat-history/')
    .then(response => response.json())
    .then(data => {
        if (data.success && data.messages.length > 0) {
            const chatMessages = document.querySelector('.chat-messages');
            chatMessages.innerHTML = ''; // 기존 메시지 제거
            
            // 메시지를 시간순으로 정렬 (오래된 것부터)
            data.messages.reverse().forEach(message => {
                addMessageToChat(message.req_content, 'user');
                addMessageToChat(message.res_content, 'ai');
            });
        }
    })
    .catch(error => {
        console.error('Error loading chat history:', error);
    });
}

function loadCurrentLLM() {
    fetch('/api/get-current-llm/')
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            console.log('Current LLM:', data.model.name);
        }
    })
    .catch(error => {
        console.error('Error loading current LLM:', error);
    });
}
</script>

<!-- 설정 모달 -->
<div id="settingsModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h3>문서 업로드 설정</h3>
            <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
        </div>
        <div class="modal-body">
            <form id="uploadSettingsForm">
                <!-- LLM 선택 -->
                <div class="form-group">
                    <label for="llmSelect">LLM 모델 선택</label>
                    <select id="llmSelect" name="selected_llm" required>
                        <option value="">LLM 모델을 선택하세요</option>
                        {% for llm in llm_list %}
                        <option value="{{ llm.id }}">{{ llm.name }} ({{ llm.get_model_type_display }})</option>
                        {% endfor %}
                    </select>
                </div>

                <!-- 텍스트 추출 가이드라인 프롬프트 -->
                <div class="form-group">
                    <label for="promptText">텍스트 추출 가이드라인 프롬프트</label>
                    <textarea id="promptText" name="prompt_text" rows="4" placeholder="문서에서 텍스트를 추출할 때 사용할 프롬프트를 입력하세요..."></textarea>
                </div>

                <!-- 청킹 설정 -->
                <div class="form-group">
                    <label for="chunkSize">청크 글자수</label>
                    <input type="number" id="chunkSize" name="chunk_size" value="1000" min="100" max="5000" required>
                    <small class="form-help">문서를 나눌 청크의 글자 수 (100-5000)</small>
                </div>

                <div class="form-group">
                    <label for="chunkOverlap">청크 겹침 글자수</label>
                    <input type="number" id="chunkOverlap" name="chunk_overlap" value="200" min="0" max="1000" required>
                    <small class="form-help">청크 간 겹치는 글자 수 (0-1000)</small>
                </div>
            </form>
        </div>
        <div class="modal-footer">
            <button type="button" class="btn btn-secondary" onclick="closeSettingsModal()">취소</button>
            <button type="button" class="btn btn-primary" onclick="saveUploadSettings()">설정 저장</button>
        </div>
    </div>
</div>

{% block extra_js %}
<script>
// 패널 토글 관련 함수들
function togglePanel(side) {
    const panel = document.getElementById(side + 'Panel');
    const toggleBtn = document.getElementById(side + 'ToggleBtn');
    
    if (panel.classList.contains('panel-hidden')) {
        panel.classList.remove('panel-hidden');
        toggleBtn.innerHTML = '<span class="icon">‹</span>';
        toggleBtn.title = '숨기기';
        
        // 로컬 스토리지에서 상태 제거
        localStorage.removeItem(side + 'PanelHidden');
        
        // 중간 패널 크기 조정
        adjustCenterPanel();
    } else {
        panel.classList.add('panel-hidden');
        
        if (side === 'left') {
            toggleBtn.innerHTML = '<span class="icon">›</span>';
        } else {
            toggleBtn.innerHTML = '<span class="icon">‹</span>';
        }
        toggleBtn.title = '보이기';
        
        // 로컬 스토리지에 상태 저장
        localStorage.setItem(side + 'PanelHidden', 'true');
        
        // 중간 패널 크기 조정
        adjustCenterPanel();
    }
}

function adjustCenterPanel() {
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');
    const centerPanel = document.getElementById('centerPanel');
    
    if (!leftPanel || !rightPanel || !centerPanel) return;
    
    const leftHidden = leftPanel.classList.contains('panel-hidden');
    const rightHidden = rightPanel.classList.contains('panel-hidden');
    
    if (leftHidden && rightHidden) {
        centerPanel.style.width = '100%';
    } else if (leftHidden || rightHidden) {
        centerPanel.style.width = '75%';
    } else {
        centerPanel.style.width = '50%';
    }
}

// 채팅 관련 함수들
let isLoading = false;

function handleKeyPress(event) {
    if (event.key === 'Enter' && !isLoading) {
        sendMessage();
    }
}

function sendMessage() {
    const chatInput = document.getElementById('chatInput');
    const message = chatInput.value.trim();
    
    if (!message || isLoading) {
        return;
    }
    
    // 선택된 문서들 가져오기
    const selectedDocuments = getSelectedDocuments();
    
    // 입력 필드 비우기
    chatInput.value = '';
    
    // 사용자 메시지 추가
    addMessageToChat(message, 'user');
    
    // 로딩 상태 설정
    isLoading = true;
    updateSendButton(true);
    
    // 로딩 애니메이션 추가
    addLoadingMessage();
    
    // API 호출 (RAG 지원)
    const requestBody = {
        message: message
    };
    
    // 선택된 문서가 있으면 RAG 모드로 전송
    if (selectedDocuments.length > 0) {
        requestBody.selected_documents = selectedDocuments;
    }
    
    fetch('/api/send-chat-message/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(requestBody)
    })
    .then(response => response.json())
    .then(data => {
        // 로딩 메시지 제거
        removeLoadingMessage();
        
        if (data.success) {
            // AI 응답 추가
            addMessageToChat(data.message, 'ai');
            
            // RAG 모드인 경우 참조 청크들 표시
            if (data.referenced_chunks && data.referenced_chunks.length > 0) {
                displayReferencedChunks(data.referenced_chunks);
            }
        } else {
            // 오류 메시지 표시
            addMessageToChat('오류: ' + data.message, 'ai', true);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        // 로딩 메시지 제거
        removeLoadingMessage();
        addMessageToChat('서버 오류가 발생했습니다.', 'ai', true);
    })
    .finally(() => {
        isLoading = false;
        updateSendButton(false);
        chatInput.focus();
    });
}

function addMessageToChat(content, sender, isError = false) {
    const chatMessages = document.querySelector('.chat-messages');
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${sender}-message`;
    
    if (isError) {
        messageDiv.style.color = '#f44336';
    }
    
    const avatar = sender === 'user' ? '👤' : '🤖';
    
    if (sender === 'user') {
        messageDiv.innerHTML = `
            <div class="message-content">${content}</div>
            <div class="message-avatar">${avatar}</div>
        `;
    } else {
        messageDiv.innerHTML = `
            <div class="message-avatar">${avatar}</div>
            <div class="message-content">${content}</div>
        `;
    }
    
    chatMessages.appendChild(messageDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function addLoadingMessage() {
    const chatMessages = document.querySelector('.chat-messages');
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'message ai-message loading';
    loadingDiv.id = 'loadingMessage';
    loadingDiv.innerHTML = `
        <div class="message-avatar">🤖</div>
        <div class="message-content">
            <div class="loading-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    `;
    
    chatMessages.appendChild(loadingDiv);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function removeLoadingMessage() {
    const loadingMessage = document.getElementById('loadingMessage');
    if (loadingMessage) {
        loadingMessage.remove();
    }
}

function updateSendButton(isLoading) {
    const sendBtn = document.querySelector('.send-btn');
    if (isLoading) {
        sendBtn.disabled = true;
        sendBtn.textContent = '전송 중...';
    } else {
        sendBtn.disabled = false;
        sendBtn.textContent = '전송';
    }
}

// 파일 업로드 관련 함수들
let selectedFiles = [];

function uploadFiles() {
    const fileInput = document.getElementById('fileInput');
    const files = fileInput.files;
    
    if (files.length === 0) {
        alert('파일을 선택해주세요.');
        return;
    }
    
    // 파일 크기 체크 (10MB)
    const maxSize = 10 * 1024 * 1024;
    for (let file of files) {
        if (file.size > maxSize) {
            alert(`파일 "${file.name}"이 너무 큽니다. 10MB 이하의 파일을 선택해주세요.`);
            return;
        }
    }
    
    // 파일 업로드
    const formData = new FormData();
    for (let file of files) {
        formData.append('file', file);
    }
    
    // 업로드 버튼 비활성화
    const uploadBtn = document.querySelector('.upload-btn');
    uploadBtn.disabled = true;
    uploadBtn.innerHTML = '<span class="upload-icon">⏳</span>';
    
    fetch('/api/upload-document/', {
        method: 'POST',
        body: formData,
        headers: {
            'X-CSRFToken': getCookie('csrftoken')
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('파일이 성공적으로 업로드되었습니다.');
            // 파일 목록 새로고침
            location.reload();
        } else {
            alert('업로드 실패: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('업로드 중 오류가 발생했습니다.');
    })
    .finally(() => {
        // 업로드 버튼 복원
        uploadBtn.disabled = false;
        uploadBtn.innerHTML = '<span class="upload-icon">↑</span>';
        fileInput.value = '';
    });
}

// 파일 선택 시 업로드 버튼 활성화
document.getElementById('fileInput').addEventListener('change', function() {
    const uploadBtn = document.querySelector('.upload-btn');
    if (this.files.length > 0) {
        uploadBtn.style.opacity = '1';
        uploadBtn.style.cursor = 'pointer';
    } else {
        uploadBtn.style.opacity = '0.5';
        uploadBtn.style.cursor = 'not-allowed';
    }
});

// 체크박스 관련 함수들
function toggleSelectAll(checkbox) {
    const fileCheckboxes = document.querySelectorAll('.file-checkbox');
    fileCheckboxes.forEach(cb => {
        cb.checked = checkbox.checked;
    });
}

function updateSelectAllCheckbox() {
    const fileCheckboxes = document.querySelectorAll('.file-checkbox');
    const selectAllCheckbox = document.querySelector('.select-all-checkbox');
    const checkedCount = document.querySelectorAll('.file-checkbox:checked').length;
    
    if (checkedCount === 0) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = false;
    } else if (checkedCount === fileCheckboxes.length) {
        selectAllCheckbox.indeterminate = false;
        selectAllCheckbox.checked = true;
    } else {
        selectAllCheckbox.indeterminate = true;
    }
}

function deleteSelectedDocuments() {
    const selectedCheckboxes = document.querySelectorAll('.file-checkbox:checked');
    
    if (selectedCheckboxes.length === 0) {
        alert('삭제할 파일을 선택해주세요.');
        return;
    }
    
    if (!confirm(`선택한 ${selectedCheckboxes.length}개의 파일을 삭제하시겠습니까?`)) {
        return;
    }
    
    const documentIds = Array.from(selectedCheckboxes).map(cb => {
        const fileItem = cb.closest('.file-item');
        return parseInt(fileItem.dataset.documentId);
    });
    
    fetch('/api/delete-documents/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            document_ids: documentIds
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert(data.message);
            location.reload();
        } else {
            alert('삭제 실패: ' + data.message);
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('삭제 중 오류가 발생했습니다.');
    });
}

function reloadFileList() {
    location.reload();
}

// 설정 모달 관련 함수들
function openSettingsModal() {
    document.getElementById('settingsModal').style.display = 'block';
    loadUploadSettings();
}

function closeSettingsModal() {
    document.getElementById('settingsModal').style.display = 'none';
}

function loadUploadSettings() {
    fetch('/api/get-upload-settings/')
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const settings = data.settings;
                if (settings.selected_llm) {
                    document.getElementById('llmSelect').value = settings.selected_llm;
                }
                if (settings.prompt_text) {
                    document.getElementById('promptText').value = settings.prompt_text;
                }
                if (settings.chunk_size) {
                    document.getElementById('chunkSize').value = settings.chunk_size;
                }
                if (settings.chunk_overlap) {
                    document.getElementById('chunkOverlap').value = settings.chunk_overlap;
                }
            }
        })
        .catch(error => {
            console.error('설정 로드 오류:', error);
        });
}

function saveUploadSettings() {
    const formData = {
        selected_llm: document.getElementById('llmSelect').value,
        prompt_text: document.getElementById('promptText').value,
        chunk_size: parseInt(document.getElementById('chunkSize').value),
        chunk_overlap: parseInt(document.getElementById('chunkOverlap').value)
    };
    
    fetch('/api/save-upload-settings/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify(formData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            alert('설정이 저장되었습니다.');
            closeSettingsModal();
        } else {
            alert('설정 저장 실패: ' + data.message);
        }
    })
    .catch(error => {
        console.error('설정 저장 오류:', error);
        alert('설정 저장 중 오류가 발생했습니다.');
    });
}

// CSRF 토큰 가져오기
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

// 페이지 로드 시 패널 상태 복원
document.addEventListener('DOMContentLoaded', function() {
    // 로컬 스토리지에서 패널 상태 복원
    const leftHidden = localStorage.getItem('leftPanelHidden') === 'true';
    const rightHidden = localStorage.getItem('rightPanelHidden') === 'true';
    
    if (leftHidden) {
        document.getElementById('leftPanel').classList.add('panel-hidden');
        document.getElementById('leftToggleBtn').innerHTML = '<span class="icon">›</span>';
        document.getElementById('leftToggleBtn').title = '보이기';
    }
    
    if (rightHidden) {
        document.getElementById('rightPanel').classList.add('panel-hidden');
        document.getElementById('rightToggleBtn').innerHTML = '<span class="icon">‹</span>';
        document.getElementById('rightToggleBtn').title = '보이기';
    }
    
    // 중간 패널 크기 조정
    adjustCenterPanel();
    
    // RAG 관련 초기화
    updateDocumentProcessingStatus();
    
    // 5초마다 처리 상태 확인 (처리 중인 문서가 있는 경우)
    setInterval(() => {
        const processingItems = document.querySelectorAll('.status-indicator.processing');
        if (processingItems.length > 0) {
            updateDocumentProcessingStatus();
        }
    }, 5000);
});

// RAG 관련 함수들

// 선택된 문서들 가져오기
function getSelectedDocuments() {
    const checkboxes = document.querySelectorAll('.file-checkbox:checked');
    return Array.from(checkboxes).map(checkbox => {
        const fileItem = checkbox.closest('.file-item');
        return parseInt(fileItem.dataset.documentId);
    });
}

// 참조 청크들 표시
function displayReferencedChunks(referencedChunks) {
    const evidenceList = document.querySelector('.evidence-list');
    if (!evidenceList) return;
    
    // 기존 근거 목록 클리어
    evidenceList.innerHTML = '<h4>참조 근거</h4>';
    
    if (referencedChunks.length === 0) {
        evidenceList.innerHTML += '<p>참조된 문서가 없습니다.</p>';
        return;
    }
    
    referencedChunks.forEach((chunk, index) => {
        const evidenceItem = document.createElement('div');
        evidenceItem.className = 'evidence-item';
        
        const similarity = (chunk.similarity * 100).toFixed(1);
        
        evidenceItem.innerHTML = `
            <div class="evidence-source">
                ${chunk.document_name} - 청크 ${chunk.chunk_index} (유사도: ${similarity}%)
            </div>
            <div class="evidence-text">
                ${chunk.content}
            </div>
        `;
        
        evidenceList.appendChild(evidenceItem);
    });
}

// 문서 처리 상태 업데이트
function updateDocumentProcessingStatus() {
    const fileItems = document.querySelectorAll('.file-item');
    
    fileItems.forEach(item => {
        const documentId = item.dataset.documentId;
        const statusIndicator = item.querySelector('.status-indicator');
        
        // 처리 상태 확인
        fetch(`/api/document/${documentId}/processing-status/`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateStatusIndicator(statusIndicator, data.processing_status, data.is_processed);
                }
            })
            .catch(error => {
                console.error('상태 확인 오류:', error);
            });
    });
}

// 상태 표시기 업데이트
function updateStatusIndicator(indicator, status, isProcessed) {
    // 기존 클래스 제거
    indicator.className = 'status-indicator';
    
    switch (status) {
        case 'completed':
            indicator.classList.add('processed');
            indicator.title = '처리 완료';
            break;
        case 'processing':
            indicator.classList.add('processing');
            indicator.title = '처리 중...';
            break;
        case 'failed':
            indicator.classList.add('failed');
            indicator.title = '처리 실패';
            break;
        default:
            indicator.classList.add('pending');
            indicator.title = '처리 대기';
            break;
    }
}

// 문서 RAG 처리 시작
function processDocumentForRAG(documentId) {
    const statusIndicator = document.querySelector(`[data-document-id="${documentId}"] .status-indicator`);
    if (statusIndicator) {
        updateStatusIndicator(statusIndicator, 'processing', false);
    }
    
    fetch('/api/process-document-for-rag/', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
            document_id: documentId
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            showNotification('문서 처리가 완료되었습니다.', 'success');
            updateDocumentProcessingStatus();
        } else {
            showNotification('문서 처리 실패: ' + data.message, 'error');
            const statusIndicator = document.querySelector(`[data-document-id="${documentId}"] .status-indicator`);
            if (statusIndicator) {
                updateStatusIndicator(statusIndicator, 'failed', false);
            }
        }
    })
    .catch(error => {
        console.error('문서 처리 오류:', error);
        showNotification('문서 처리 중 오류가 발생했습니다.', 'error');
    });
}

// 알림 표시 함수
function showNotification(message, type = 'info') {
    // 기존 알림 제거
    const existingNotification = document.querySelector('.notification');
    if (existingNotification) {
        existingNotification.remove();
    }
    
    // 새 알림 생성
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    
    // 스타일 적용
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        padding: 12px 20px;
        border-radius: 4px;
        color: white;
        font-weight: bold;
        z-index: 1000;
        animation: slideIn 0.3s ease-out;
    `;
    
    // 타입별 색상
    switch (type) {
        case 'success':
            notification.style.backgroundColor = '#4CAF50';
            break;
        case 'error':
            notification.style.backgroundColor = '#f44336';
            break;
        case 'warning':
            notification.style.backgroundColor = '#ff9800';
            break;
        default:
            notification.style.backgroundColor = '#2196F3';
            break;
    }
    
    document.body.appendChild(notification);
    
    // 3초 후 자동 제거
    setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in';
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 300);
    }, 3000);
}

// 페이지 로드 시 처리 상태 업데이트
document.addEventListener('DOMContentLoaded', function() {
    updateDocumentProcessingStatus();
    
    // 5초마다 처리 상태 확인 (처리 중인 문서가 있는 경우)
    setInterval(() => {
        const processingItems = document.querySelectorAll('.status-indicator.processing');
        if (processingItems.length > 0) {
            updateDocumentProcessingStatus();
        }
    }, 5000);
});

// CSS 애니메이션 추가
const style = document.createElement('style');
style.textContent = `
    @keyframes slideIn {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOut {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }
    
    .status-indicator.processed {
        background-color: #4CAF50 !important;
    }
    
    .status-indicator.processing {
        background-color: #ff9800 !important;
        animation: pulse 1s infinite;
    }
    
    .status-indicator.failed {
        background-color: #f44336 !important;
    }
    
    .status-indicator.pending {
        background-color: #9E9E9E !important;
    }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
    
    .evidence-item {
        margin-bottom: 15px;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #f9f9f9;
    }
    
    .evidence-source {
        font-weight: bold;
        color: #333;
        margin-bottom: 5px;
    }
    
    .evidence-text {
        color: #666;
        font-size: 14px;
        line-height: 1.4;
    }
`;
document.head.appendChild(style);
</script>
{% endblock %}
